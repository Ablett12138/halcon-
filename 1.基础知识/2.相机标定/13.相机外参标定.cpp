/**********************          相机标定  --外参求取           **********************/
* Attention:
* This program reads the internal camera parameters from the file
* 'camera_parameters.dat', which, e.g., could be generated by the program
* 'camera_calibration_internal.hdev'

ImgPath := '3d_machine_vision/calib/'
dev_close_window ()
dev_open_window (0, 0, 652, 494, 'black', WindowHandle)
dev_update_off ()
dev_set_draw ('margin')
dev_set_line_width (1)
set_display_font (WindowHandle, 14, 'mono', 'true', 'false')
* Read the internal camera parameters from file
try
    read_cam_par ('camera_parameters.dat', CamParam)
catch (Exception)
    * run 'camera_calibration_internal.hdev' first to generate camera
    * parameter file 'camera_parameters.dat'
    stop ()
endtry
* 
* Determine the external camera parameters and world coodinates from image points
* 
* The external camera parameters can be determined from an image, where the
* calibration plate is positioned directly on the measurement plane
read_image (Image, ImgPath + 'calib_11')
dev_display (Image)
CaltabName := 'caltab_30mm.descr'
create_calib_data ('calibration_object', 1, 1, CalibDataID)
* Here, the final camera parameters are already known and can be used instead
* of the starting values used in the program 'camera_calibration_internal.hdev'
set_calib_data_cam_param (CalibDataID, 0, [], CamParam)
set_calib_data_calib_object (CalibDataID, 0, CaltabName)
find_calib_object (Image, CalibDataID, 0, 0, 1, [], [])
get_calib_data_observ_contours (Caltab, CalibDataID, 'caltab', 0, 0, 1)
get_calib_data_observ_points (CalibDataID, 0, 0, 1, RCoord, CCoord, Index, PoseForCalibrationPlate)
dev_set_color ('green')
dev_display (Caltab)
dev_set_color ('red')
*显示标定点
disp_caltab (WindowHandle, CaltabName, CamParam, PoseForCalibrationPlate, 1)
dev_set_line_width (3)
*每个标定点画圆
disp_circle (WindowHandle, RCoord, CCoord, gen_tuple_const(|RCoord|,1.5))
* caltab_points (CaltabName, X, Y, Z)
* calibrate_cameras (CalibDataID, Error)
* To take the thickness of the calibration plate into account, the z-value
* of the origin given by the camera pose has to be translated by the
* thickness of the calibration plate.
* Deactivate the following line if you do not want to add the correction.
*设置初始位姿   --x=0,y=0,z=0.00075 z为标定板的厚度
set_origin_pose (PoseForCalibrationPlate, 0, 0, 0.00075, PoseForCalibrationPlate)
*清除变动版的数据
clear_calib_data (CalibDataID)
disp_continue_message (WindowHandle, 'black', 'true')
stop ()
* Alternatively, the external camera parameters can  be determined from
* at least three point correspondances between the WCS and the pixel coordinate system
*读取需要测量的图像
read_image (Image, ImgPath + 'caliper_01')
dev_display (Image)
* Set the world coordinates of three points on the rule
*设置世界坐标内的三个点以及0,0，0点位置
X := [0, 50, 100, 80]
Y := [5, 0, 5, 0]
Z := [0, 0, 0, 0]
* Set the respective image plane coordinates of the three points
*设置图像中的四个点各自的图像平面坐标
RCoord := [414, 227, 85, 128]
CCoord := [119, 318, 550, 448]
*显示选取的四个点
disp_cross (WindowHandle, RCoord, CCoord, 6, 0)
* create_pose (-50, 25, 400, 0, 0, -30, 'Rp+T', 'gba', 'point', InitialPose)
*计算世界坐标与图像坐标之间关系的矩阵   --至少三到四个点
vector_to_pose (X, Y, Z, RCoord, CCoord, CamParam, 'iterative', 'error', FinalPose, Errors)
*记录位姿数据
write_pose (FinalPose, 'pose_from_three_points.dat')
* Now, transform a point measured interactively into the WCS
dev_update_window ('on')
dev_display (Image)
while (1)
    disp_message (WindowHandle, 'Measure one point: left mouse button', 'window', 12, 12, 'red', 'false')
    disp_message (WindowHandle, 'Exit measure mode: right mouse button', 'window', 36, 12, 'red', 'false')
    *获取鼠标左右键 右键==>button=4
    get_mbutton (WindowHandle, Row, Column, Button)
    if (Button == 4)
        break
    endif
    dev_display (Image)
    dev_set_color ('green')
    *显示左键点击的坐标
    disp_cross (WindowHandle, Row, Column, 6, 0)
    *将图像上的点转换为世界坐标
    image_points_to_world_plane (CamParam, FinalPose, Row, Column, 1, X1, Y1)
    disp_message (WindowHandle, 'X = ' + X1, 'window', 320, 400, 'red', 'false')
    disp_message (WindowHandle, 'Y = ' + Y1, 'window', 340, 400, 'red', 'false')
endwhile
* Apply the measure tool and transform the resulting point coordinates
* into the WCS
dev_set_color ('red')
dev_display (Image)
* Set the world coordinates of four points defining a ROI for the measure tool
*世界坐标系上的四个点确定测量工具的roi区域
ROI_X_WCS := [-2, -2, 112, 112]
ROI_Y_WCS := [0, 0.5, 0.5, 0]
ROI_Z_WCS := [0, 0, 0, 0]
* Determine the transformation matrix from the WCS into the CCS
*由位姿确定世界坐标到相机坐标的变换矩阵
pose_to_hom_mat3d (FinalPose, CCS_HomMat_WCS)
* Transform the point coordintes into the image coordinate system
affine_trans_point_3d (CCS_HomMat_WCS, ROI_X_WCS, ROI_Y_WCS, ROI_Z_WCS, CCS_RectangleX, CCS_RectangleY, CCS_RectangleZ)
project_3d_point (CCS_RectangleX, CCS_RectangleY, CCS_RectangleZ, CamParam, RectangleRow, RectangleCol)
gen_region_polygon_filled (ROI, RectangleRow, RectangleCol)
dev_display (ROI)
stop ()
*求出图像的最小外接矩形
smallest_rectangle2 (ROI, RowCenterROI, ColCenterROI, PhiROI, Length1ROI, Length2ROI)
* Create a measure
gen_measure_rectangle2 (RowCenterROI, ColCenterROI, PhiROI, Length1ROI, Length2ROI, 652, 494, 'bilinear', MeasureHandle)
measure_pairs (Image, MeasureHandle, 0.4, 5, 'all_strongest', 'all', RowEdgeFirst, ColumnEdgeFirst, AmplitudeFirst, RowEdgeSecond, ColumnEdgeSecond, AmplitudeSecond, IntraDistance, InterDistance)
close_measure (MeasureHandle)
dev_display (Image)
disp_message (WindowHandle, 'Measuring the position of the pitch lines', 'window', 450, 25, 'red', 'false')
dev_set_color ('green')
RowPitchLine := (RowEdgeFirst + RowEdgeSecond) / 2.0
ColPitchLine := (ColumnEdgeFirst + ColumnEdgeSecond) / 2.0
disp_cross (WindowHandle, RowPitchLine, ColPitchLine, 6, 0)
image_points_to_world_plane (CamParam, FinalPose, RowPitchLine, ColPitchLine, 1, X1, Y1)
for I := 1 to |X1| by 1
    set_tposition (WindowHandle, RowEdgeFirst[I - 1] + 5, ColumnEdgeFirst[I - 1] - 20)
    if (I == |X1|)
        set_tposition (WindowHandle, RowEdgeFirst[I - 1], ColumnEdgeFirst[I - 2])
    endif
    write_string (WindowHandle, X1[I - 1]$'.3f' + 'mm')
endfor
disp_continue_message (WindowHandle, 'black', 'true')
stop ()
dev_display (Image)
* Apply a line extraction and transform the resulting XLD contours
* into the WCS
* Set the world coordinates of four points defining a ROI
ROI_X_WCS := [11, 11, 13, 13]
ROI_Y_WCS := [4, 6, 6, 4]
ROI_Z_WCS := [0, 0, 0, 0]
* Transform the point coordinates into the image coordinate system
affine_trans_point_3d (CCS_HomMat_WCS, ROI_X_WCS, ROI_Y_WCS, ROI_Z_WCS, CCS_RectangleX, CCS_RectangleY, CCS_RectangleZ)
project_3d_point (CCS_RectangleX, CCS_RectangleY, CCS_RectangleZ, CamParam, RectangleRow, RectangleCol)
* Visualize the square in the original image
disp_polygon (WindowHandle, [RectangleRow,RectangleRow[0]], [RectangleCol,RectangleCol[0]])
dev_display (Image)
* create the ROI
gen_region_polygon_filled (ROI, RectangleRow, RectangleCol)
reduce_domain (Image, ROI, ImageReduced)
* Extract the lines
lines_gauss (ImageReduced, Lines, 1, 3, 8, 'dark', 'true', 'bar-shaped', 'true')
* Adapt the pose of the measurement plane to the tilted plane of the vernier
RelPose := [0, 3.2, 0, -14, 0, 0, 0]
pose_to_hom_mat3d (FinalPose, HomMat3D)
pose_to_hom_mat3d (RelPose, HomMat3DRel)
hom_mat3d_compose (HomMat3D, HomMat3DRel, HomMat3DAdapted)
* Alternatively, the adaption can be done using the operators
* hom_mat3d_translate_local and hom_mat3d_rotate_local
* as shown in the following two lines
hom_mat3d_translate_local (HomMat3D, 0, 3.2, 0, HomMat3DTranslate)
hom_mat3d_rotate_local (HomMat3DTranslate, rad(-14), 'x', HomMat3DAdapted)
hom_mat3d_to_pose (HomMat3DAdapted, PoseAdapted)
* Transform the XLD contour to the WCS using the adapted pose
contour_to_world_plane_xld (Lines, ContoursTrans, CamParam, PoseAdapted, 1)
get_contour_xld (ContoursTrans, YOfContour, XOfContour)
tuple_mean (XOfContour, MeterReading)
dev_display (Lines)
disp_message (WindowHandle, 'Meter reading: ' + MeterReading$'.3f' + 'mm', 'window', 400, 180, 'green', 'false')
disp_continue_message (WindowHandle, 'black', 'true')
stop ()
dev_close_inspect_ctrl (YOfContour)
dev_close_inspect_ctrl (XOfContour)
* Now, transform the whole image
WidthMappedImage := 652
HeightMappedImage := 494
dev_display (Image)
* First, determine the scale for the mapping
* (here, the scale is determined such that in the
* surroundings of the points P0 and P1, the image scale of the
* mapped image is similar to the image scale of the original image)
distance_pp (X[0], Y[0], X[1], Y[1], DistP0P1WCS)
distance_pp (RCoord[0], CCoord[0], RCoord[1], CCoord[1], DistP0P1PCS)
Scale := DistP0P1WCS / DistP0P1PCS
* Then, determine the parameter settings for set_origin_pose such
* that the point given via get_mbutton will be in the center of the
* mapped image
dev_display (Image)
disp_message (WindowHandle, 'Define the center of the mapped image', 'window', 12, 12, 'red', 'false')
get_mbutton (WindowHandle, CenterRow, CenterColumn, Button1)
image_points_to_world_plane (CamParam, FinalPose, CenterRow, CenterColumn, 1, CenterX, CenterY)
set_origin_pose (FinalPose, CenterX - Scale * WidthMappedImage / 2.0, CenterY - Scale * HeightMappedImage / 2.0, 0, PoseNewOrigin)
gen_image_to_world_plane_map ( Map, CamParam, PoseNewOrigin, 652, 494, WidthMappedImage, HeightMappedImage, Scale, 'bilinear')
map_image (Image, Map, ImageMapped)
dev_clear_window ()
dev_display (ImageMapped)
* In the case that only one image has to be mapped, the operator
* image_to_world_plane can be used instead of the operators
* gen_image_to_world_plane_map and map_image.
image_to_world_plane (Image, ImageMapped, CamParam, PoseNewOrigin, WidthMappedImage, HeightMappedImage, Scale, 'bilinear')